---
name: test-approach
description: テスト戦略の適用ガイド。受け入れ基準からテストケースへの変換、テスト粒度の判断、テストファーストの進め方。/implement でテスト作成するとき、テストの過不足を判断するとき、テスト設計のレビュー時に使用する。
commands: ["/implement", "/review"]
---

# テスト戦略適用ガイド

## テスト作成アプローチ

### 推奨: テストファースト

受け入れ基準からテストを先に書き、テストが通るように実装する。

**理由**:
- 受け入れ基準の曖昧さを実装前に検出できる
- 仕様を満たす最小限の実装に集中できる
- AIが実装する場合、テストという明確なゴールがあるとブレにくい

**ただし強制はしない**: 既存コードの修正や探索的な実装ではテストラストが適切な場合もある。

## 受け入れ基準→テストケース変換

### 手順

1. 受け入れ基準を1つずつテストケースに変換する
2. 正常系のハッピーパスを最初に書く
3. 異常系・境界値を追加する
4. テスト名は日本語で、受け入れ基準との対応が分かるように命名する

### 例

```
受け入れ基準:
- [ ] ユーザーが招待メールを送信する → 招待が作成され、メールが送信される

テスト:
describe('招待メール送信', () => {
  it('招待メールを送信すると、招待レコードが作成されメールが送信される', ...)
  it('無効なメールアドレスの場合、バリデーションエラーが返される', ...)
  it('既に有効な招待がある場合、既存の招待が無効化され新しい招待が作成される', ...)
})
```

## テスト粒度の判断

| テストの種類 | 対象 | 書くべきとき |
|---|---|---|
| ユニットテスト | ビジネスロジック・ドメインモデル | 常に |
| 統合テスト | DB・外部API境界 | 外部依存がある場合 |
| E2E テスト | ユーザーフロー全体 | クリティカルパスのみ |

### ユニットテストの範囲

- ドメインモデルの不変条件 → 必須
- ユースケースの分岐 → 必須
- ユーティリティ関数 → 入出力が明確なもの
- UI コンポーネント → ビジネスロジックを含むもの

### テストを書かない判断

- フレームワークが保証する動作（ルーティング等）
- 単純な CRUD の薄いラッパー
- 外部ライブラリの動作確認

### テストレベルの選択

受け入れ基準に対して「どのレベルでテストすべきか」の判断:

| 基準 | ユニットテスト | 統合テスト |
|---|---|---|
| ビジネスロジックの正しさ | ○ | - |
| DB に依存する動作 | モックで検証 | 実 DB で検証 |
| 外部 API 連携 | モックで検証 | テスト用エンドポイントで検証 |
| 複数コンポーネントの協調 | - | ○ |

- 1つの受け入れ基準を複数レベルで重複テストしない
- 最も効率的なレベル（高速・安定・保守しやすい）を選ぶ

## テストデータ

- ファクトリパターンを使う（ハードコード禁止）
- テスト間の独立性を保つ（共有状態を持たない）
- 詳細は docs/qa/test-data-management.md を参照

## テスト命名規約

- テスト名は日本語で記述する
- 「何をテストしているか」が名前から分かること
- describe で機能単位、it でシナリオを記述する
- 不変条件やビジネスルールのテストでは、対応する BR-N を含めて追跡可能にする
  - 例: `describe('BR-1: 招待メールの有効期限', () => { ... })`
- Arrange-Act-Assert パターンに従う
