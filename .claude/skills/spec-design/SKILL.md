---
name: spec-design
description: 要件から仕様への構造化、API設計、ドメインモデリングのパターン。/create-spec の実行時、API仕様の設計時、ドメインモデル（集約・エンティティ・値オブジェクト）の定義時に使用する。
commands: ["/create-spec"]
---

# 仕様設計ガイド

## 要件→仕様の構造化

### 集約の手順

1. 関連する requirements を全て読み込む
2. ビジネスルールを抽出し、ドメインごとにグループ化する
3. overview.md のビジネスルール一覧に統合する（出典の requirements を付記）
4. ルール間の矛盾・重複がないか検証する

### specs 更新時の原則

- 新しい requirements を反映するとき、既存 specs との整合性を確認する
- 矛盾がある場合は requirements 側で解決してから specs を更新する
- specs のある部分を削除する場合、コミットメッセージに削除理由を残す

## API 設計

### エンドポイント設計

- リソース指向で設計する（動詞ではなく名詞）
- ネストは2階層まで: `/api/v1/{{resource}}/{{id}}/{{sub-resource}}`
- 一覧取得はページネーション必須（cursor or offset）
- フィルタはクエリパラメータ: `?status=active&sort=created_at`

### レスポンス設計

- 一貫したエンベロープ形式を使う
- エラーレスポンスは `error` + `message` の統一フォーマット
- 日時は ISO 8601、IDは UUID を基本とする
- null と未設定（フィールド不在）の区別方針を決める

### バージョニング

- URL パスに `/v1/` を含める
- 破壊的変更は新バージョンで対応する

## ドメインモデリング

### 集約の見つけ方

- 「一緒に変更されるデータ」をグループ化する
- トランザクション境界 = 集約境界
- 集約は小さく保つ（巨大集約はパフォーマンス問題の元）

### エンティティ vs 値オブジェクト

| 問い | エンティティ | 値オブジェクト |
|---|---|---|
| IDで追跡する必要がある？ | Yes | No |
| 属性が変わっても同じもの？ | Yes | No |
| 同じ属性なら交換可能？ | No | Yes |

- **エンティティ**: 同一性（ID）で識別。ライフサイクルがある
- **値オブジェクト**: 属性の組み合わせで識別。不変。交換可能

### 不変条件の定義

- 集約が常に満たすべきビジネスルールを列挙する
- 不変条件はドメインモデルのコードで強制する（DB制約だけに頼らない）
- requirements の BR-N を参照して追跡可能にする

### ステータス遷移

状態を持つエンティティがある場合:

1. 全ての状態を列挙する
2. 許可される遷移とトリガーを定義する
3. 遷移の事前条件を明記する
4. 不正な遷移をコードで防止する

## クロスドメイン参照

### 他ドメインの仕様を参照する場合

- 参照先ドメインの overview.md へのパスを明記する
- 参照する情報（ビジネスルールID、APIエンドポイント等）を具体的に記載する
- 参照元と参照先の双方に相互参照を記録する

### 参照の書き方

overview.md の「コンテキスト（AI向け）> このドメインの重要な制約」に記載する:

```markdown
- {{制約}} — 依存先: docs/specs/{{other-domain}}/overview.md の BR-3
```

依存先の overview.md 側にも逆方向の参照を追記する:

```markdown
- docs/specs/{{this-domain}}/overview.md から BR-3 を参照されている
```

### 参照管理の原則

- ドメイン間の依存は最小限にする（疎結合）
- 循環参照が発生した場合はドメイン境界の見直しを検討する
- 共通の概念が複数ドメインに現れる場合、どちらが「正」かを ADR で決定する
