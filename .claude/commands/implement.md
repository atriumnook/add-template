# 実装プロセス

要件と仕様に基づいてコードを実装する。手順をスキップしない。

## スコープ判定

まず対象タスクの性質を判断する:

- **仕様変更を伴う機能追加・変更** → 「前提確認」から全手順を実行
- **仕様変更を伴わないバグ修正** → requirements/specs の作成・更新は不要。既存の仕様と受け入れ基準を確認し、「実行手順」の Step 2 から開始する（ブランチは `fix/` プレフィックスを使用）
- **本番障害の緊急対応** → 「緊急対応フロー」を参照
- **軽微な修正（Quick モード）** → specs への影響がないバグ修正・設定変更・リファクタリング。requirements/specs の作成・更新は不要。docs/state.md の調査メモに内容を記録し、「実行手順」の Step 2 から開始する（ブランチは `fix/` プレフィックスを使用）

## 前提確認

1. **要件を確認する**
   - `docs/requirements/{{TICKET_ID}}*.md` から対象チケットの要件ファイルを読み込む
   - 要件ファイルが存在しない場合 → 実装に進まず、/create-requirement の実行を提案する
   - 受け入れ基準を把握する（status: draft または approved のものを優先的に確認）
   - depends_on に記載された前提要件が implemented 状態であることを確認する
   - 受け入れ基準が具体的でテスト可能な形になっていることを確認する。不十分な場合は実装に進まず、要件のブラッシュアップを提案する

2. **仕様を確認する**
   - `docs/specs/{{domain-name}}/overview.md` の「コンテキスト（AI向け）」セクションに列挙されたファイルを全て読み込む
   - 仕様書が存在しない場合 → 実装に進まず、/create-spec の実行を提案する
   - API仕様・ドメインモデルを把握する

3. **技術コンテキストを確認する**
   - CLAUDE.md のアーキテクチャ方針
   - .claude/rules/coding-style.md のコーディング規約
   - docs/qa/test-strategy.md のテスト方針

## 実行手順

### Step 1. feature ブランチを作成する（未作成の場合）

- `feat/{{TICKET_ID}}-{{feature-name}}`（機能追加）
- `fix/{{TICKET_ID}}-{{feature-name}}`（バグ修正）

### Step 2. テストを作成する（テストファースト推奨）

- 受け入れ基準をテストケースに変換する
- ユニットテスト: ビジネスロジック・ドメインモデルの検証
- 統合テスト: 外部サービス・DB境界の検証（必要に応じて）
- テスト名は日本語で、何をテストしているか明確に
- docs/qa/test-strategy.md の方針に従う
- テストの粒度・方針に迷ったら **test-approach** スキルを参照
- テストが期待通りに失敗しない場合:
  - テストの前提条件を確認する（モックの設定、テストデータ等）
  - 受け入れ基準の解釈が正しいか要件を再確認する

### Step 3. コードを実装する

- specs の仕様に準拠すること
- アーキテクチャ方針に沿った配置にすること
- コーディング規約に従うこと
- テストが通ることを確認しながら進める

### Step 4. 仕様の更新が必要か確認する

実装中に仕様の不備・不整合に気づいた場合、不備の程度に応じて対応する。

#### 軽微な不備（表記揺れ、明らかな記載漏れ、自明な補完）

同一ブランチ内で対応する:
1. requirements に補足・修正を追記する
2. specs を更新する
3. 実装を継続する
4. コミットメッセージに修正内容を記載する

#### 重大な不備（仕様の矛盾、設計の見直しが必要、ビジネスルールの変更）

実装を一旦停止し、仕様を確定させてから再開する:
1. 実装途中のコードをコミットまたはスタッシュする
2. 要件の変更を /create-requirement のフローで記録する（MODIFIED セクションを使用）
3. /create-spec のフローで仕様を更新する
4. 変更内容がチームの合意を要する場合は、レビューを依頼する
5. 仕様が確定したら実装を再開する

**いずれの場合も specs を直接編集してはならない**（requirements → specs の順序を守る）。

### Step 5. セルフチェック

consistency-check スキルの Layer 2〜3 に従って以下を確認する:

- **specs → code**: API 仕様のエンドポイント・リクエスト・レスポンスがコードと一致するか
- **code → test**: 受け入れ基準に対応するテストが存在するか。正常系・異常系の両方がテストされているか
- lint / format が通ること
- テストが全て通ること

### Step 6. docs/state.md を更新する

- 「現在の作業」セクションのフェーズを `review` に更新する
- 「セッション履歴」に実施内容と次回アクションを記録する
- ブロッカーがあった場合は「ブロッカー」セクションに記録する
- 判断を下した場合は「判断ログ」に記録する

### コミット戦略

PR 内のコミット構成は `.claude/rules/git-workflow.md` の「PR内のコミット構成」に従う。軽微な変更は1コミットにまとめても良い。

## 関連スキル

- **test-approach**（Step 2）: テストファースト推奨、受け入れ基準→テストケース変換、テスト粒度の判断
- **parallel-execution**（Step 3）: 独立タスクの並列実行判断
- **consistency-check**（Step 5）: 実装完了時のセルフチェック基準

## 完了条件

- [ ] 要件の受け入れ基準が全て満たされている
- [ ] テストが作成され、全て通っている
- [ ] コーディング規約に準拠している
- [ ] 仕様変更があった場合、requirements → specs の順で更新されている
- [ ] 新しい用語が出現した場合、docs/project.md の用語集に追加されている
- [ ] PR 作成の準備ができている（/review を次に実行）
- [ ] docs/state.md のセッション履歴が更新されている

---

## 緊急対応フロー

本番障害など緊急度が高く、通常のドキュメントファーストのフローを踏む時間がない場合に使用する。

### 手順

1. **`hotfix/` ブランチを作成する**
   - `hotfix/{{TICKET_ID}}-{{issue-name}}`

2. **修正を実装しデプロイする**
   - 最小限の修正に留める
   - テストを追加する（リグレッション防止）

3. **事後ドキュメントを作成する**（修正後、速やかに）
   - 仕様変更を伴う場合: requirements に MODIFIED セクション付きで経緯を記録 → specs を更新
   - 仕様変更なしの場合: コミットメッセージに原因と修正内容を記録

### 事後チェックリスト

- [ ] 修正がデプロイされている
- [ ] リグレッションテストが追加されている
- [ ] 仕様変更がある場合、requirements → specs が更新されている
- [ ] 根本原因の分析と再発防止策が検討されている
