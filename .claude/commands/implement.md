# 実装プロセス

要件と仕様に基づいてコードを実装する。手順をスキップしない。

## スコープ判定

まず対象タスクの性質を判断する:

- **仕様変更を伴う機能追加・変更** → 「前提確認」から全手順を実行
- **仕様変更を伴わないバグ修正** → requirements/specs の作成・更新は不要。既存の仕様と受け入れ基準を確認し、「実行手順」の Step 2 から開始する（ブランチは `fix/` プレフィックスを使用）
- **本番障害の緊急対応** → 「緊急対応フロー」を参照
- **軽微な修正（Quick モード）** → specs への影響がないバグ修正・設定変更・リファクタリング。requirements/specs の作成・更新は不要。docs/state.md の調査メモに内容を記録し、「実行手順」の Step 2 から開始する（ブランチは `fix/` プレフィックスを使用）

## 前提確認

1. **要件を確認する**
   - `docs/requirements/{{TASK_ID}}*.md` から対象タスクの要件ファイルを読み込む
   - 要件ファイルが存在しない場合 → 実装に進まず、/create-requirement の実行を提案する
   - 受け入れ基準を把握する（status: draft または approved のものを優先的に確認）
   - depends_on に記載された前提要件が implemented 状態であることを確認する
   - 受け入れ基準が具体的でテスト可能な形になっていることを確認する。不十分な場合は実装に進まず、要件のブラッシュアップを提案する

2. **仕様を確認する**
   - `docs/specs/{{domain-name}}/overview.md` の「コンテキスト（AI向け）」セクションに列挙されたファイルを全て読み込む
   - 仕様書が存在しない場合 → 実装に進まず、/create-spec の実行を提案する
   - API仕様・ドメインモデルを把握する

3. **技術コンテキストを確認する**
   - CLAUDE.md のアーキテクチャ方針
   - .claude/rules/coding-style.md のコーディング規約
   - docs/qa/test-strategy.md のテスト方針

## 実行手順

### Step 1. ブランチを準備する

1. `git branch --show-current` で現在のブランチを確認する
2. 分岐:
   - main にいる → ブランチを作成する: `git switch -c feat/{{TASK_ID}}-{{feature-name}}`
   - 対象タスクのブランチにいる → そのまま続行
   - 別のタスクのブランチにいる → main に戻り、新規ブランチを作成する
3. `git status` で未コミットの変更を確認する
   - 変更がある場合 → WIP コミットしてから作業開始（コミットメッセージに `WIP` を含めると Hook のテスト/lint が自動スキップされる）

※ 実装（src/、tests/ の変更）は必ず feature ブランチ上で行う。main 上での直接的なコード変更は禁止

### Step 2. テストを作成する（テストファースト推奨）

- 受け入れ基準をテストケースに変換する
- ユニットテスト: ビジネスロジック・ドメインモデルの検証
- 統合テスト: 外部サービス・DB境界の検証（必要に応じて）
- テスト名は日本語で、何をテストしているか明確に
- docs/qa/test-strategy.md の方針に従う
- テストの粒度・方針に迷ったら **test-approach** スキルを参照
- テストが期待通りに失敗しない場合:
  - テストの前提条件を確認する（モックの設定、テストデータ等）
  - 受け入れ基準の解釈が正しいか要件を再確認する

### Step 3. コードを実装する

- specs の仕様に準拠すること
- アーキテクチャ方針に沿った配置にすること
- コーディング規約に従うこと
- テストが通ることを確認しながら進める

### Step 4. 仕様の更新が必要か確認する

実装中に仕様の不備・不整合に気づいた場合、不備の程度に応じて対応する。

#### 軽微な不備（表記揺れ、明らかな記載漏れ、自明な補完）

同一ブランチ内で対応する:
1. requirements に補足・修正を追記する
2. specs を更新する
3. 実装を継続する
4. コミットメッセージに修正内容を記載する

#### 重大な不備（仕様の矛盾、設計の見直しが必要、ビジネスルールの変更）

実装を一旦停止し、仕様を確定させてから再開する:
1. 実装途中のコードをコミットまたはスタッシュする
2. 要件の変更を /create-requirement のフローで記録する（MODIFIED セクションを使用）
3. /create-spec のフローで仕様を更新する
4. 変更内容がチームの合意を要する場合は、レビューを依頼する
5. 仕様が確定したら実装を再開する

**いずれの場合も specs を直接編集してはならない**（requirements → specs の順序を守る）。

### Step 5. セルフチェック

以下を**実際に実行**する。スキップしない。

1. `{{LINT_COMMAND}}` を実行する。失敗したら修正して再実行する
2. `{{TEST_COMMAND}}` を実行する。失敗したら修正して再実行する
3. 3回修正しても解決しない場合はユーザーに報告する
4. requirements の受け入れ基準を1つずつ確認する:
   - 各基準に対応するテストが存在し PASS しているか
   - 未達の基準がある場合 → Step 2 または Step 3 に戻る

※ Quick モード（requirements なし）の場合は 1〜3 のみ実行する
※ コミット時にも Hook がテスト/lint を自動実行する（二重チェック）

consistency-check スキルの Layer 2〜3 も参照:
- specs → code: API仕様とコードの一致
- code → test: 受け入れ基準のテストカバレッジ

### Step 6. docs/state.md を更新する

- 「現在の作業」セクションのフェーズを `review` に更新する
- 「セッション履歴」に実施内容と次回アクションを記録する
- ブロッカーがあった場合は「ブロッカー」セクションに記録する
- 判断を下した場合は「判断ログ」に記録する

### Step 7. コミットして作業を完了する

1. `git status` で未コミットの変更を確認する
2. 全変更をコミットする（コミット形式は .claude/rules/git-workflow.md に従う）
3. `git status` でワーキングツリーがクリーンであることを確認する
   - 未追跡ファイルが残っている場合 → コミットに含めるか .gitignore に追加する
4. `git log --oneline -5` でコミット履歴を確認し、ユーザーに報告する

※ コミット時に Hook がテスト/lint を自動実行する。失敗するとコミットがブロックされる。
※ 作業完了後は /review を実行して PR 作成・レビューに進む。

### コミット戦略

作業中も論理的な作業単位でこまめにコミットすることを推奨する（テスト作成後、実装後、ドキュメント更新後など）。
最終的に Squash Merge されるため、中間コミットの粒度は厳密でなくてよい。

## 関連スキル

- **test-approach**（Step 2）: テストファースト推奨、受け入れ基準→テストケース変換、テスト粒度の判断
- **parallel-execution**（Step 3）: 独立タスクの並列実行判断
- **consistency-check**（Step 5）: 実装完了時のセルフチェック基準

## 完了条件

- [ ] 要件の受け入れ基準が全て満たされている
- [ ] テストが作成され、全て通っている
- [ ] コーディング規約に準拠している
- [ ] 仕様変更があった場合、requirements → specs の順で更新されている
- [ ] 新しい用語が出現した場合、docs/project.md の用語集に追加されている
- [ ] 全変更がコミット済みで、ワーキングツリーがクリーンである
- [ ] docs/state.md のセッション履歴が更新されている
- [ ] 次のアクション: /review を実行して PR 作成・レビューに進む

---

## 緊急対応フロー

本番障害など緊急度が高く、通常のドキュメントファーストのフローを踏む時間がない場合に使用する。

### 手順

1. **`hotfix/` ブランチを作成する**
   - `hotfix/{{TASK_ID}}-{{issue-name}}`

2. **修正を実装しデプロイする**
   - 最小限の修正に留める
   - テストを追加する（リグレッション防止）

3. **事後ドキュメントを作成する**（修正後、速やかに）
   - 仕様変更を伴う場合: requirements に MODIFIED セクション付きで経緯を記録 → specs を更新
   - 仕様変更なしの場合: コミットメッセージに原因と修正内容を記録

### 事後チェックリスト

- [ ] 修正がデプロイされている
- [ ] リグレッションテストが追加されている
- [ ] 仕様変更がある場合、requirements → specs が更新されている
- [ ] 根本原因の分析と再発防止策が検討されている
